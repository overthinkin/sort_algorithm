# 선택 삽입 버블 퀵

방법의 장점과 단점, 다른 방법과의 비교, 시간 복잡도

------

> 구현이 단순하지만 수행이 느린 알고리즘: **선택정렬, 삽입정렬, 버블정렬**
>
> 구현이 복잡하지만 수행 시간이 짧은 알고리즘: **퀵 정렬**

### 1. 선택 정렬  [시간복잡도: O(N^2)]

가장 작은 원소를 선택하여 맨 앞으로 옮겨 정렬한다.
배열의 크기 N만큼 한 원소와 전체 원소를 비교한다. 모든 원소가 비교 대상이 될 때까지 비교한다.
장점: 구현이 간편하다. 이동횟수는 미리 결정된다. 이동횟수:  3(n-1)
단점: 이동횟수 3(n-1)은 큰 값이다. 느리기 때문에 비효율적이다.
중복된 값이 배열에 존재하는 경우 상대적인 위치가 불필요하게 변경된다.

### 2. 삽입 정렬 [시간복잡도: O(N^2)]

기존 배열에 새로운 원소를 맨 뒤에 삽입하여 순차적으로 비교한다.
*신규 원소만이 비교 대상* 이 되기 때문에 최적의 경우 시간복잡도가 O(N)이 될 수 있지만, 평균적으로 O(N^2)의 시간복잡도를 가지고 있다.

장점: 이미 정렬되어 있는 배열의 경우 계산 속도가 빠르다. 삽입 정렬은 선택정렬과 다르게 안정성을 만족한다. 이미 정렬된 원소는 다시 비교하지 않는다. 레코드가 미리 정렬되어 있거나 크기가 작은 경우에 유리하다.
단점: 레코드의 이동이2(n-1)번이다.  이동횟수가 크다. 느리기 때문에 비효율적이다.

### 3. 버블 정렬 [시간복잡도: O(N^2)]

인접한 두 개의 원소를 비교하며 서로의 자리를 바꾼다. 반복하다보면 큰 값이 계속해서 뒤로 이동하는 모습이다. 배열의 크기 N만큼 전체 원소와 대상 원소를 비교한다. 
장점: 비교 방법이 간편하기 때문에 구현이 쉽다. 다른 공간에 저장하지 않기 때문에 추가적인 메모리가 필요 없다. 최선의 경우는 자료가 이미 정렬되어 자리 이동을 하지 않는 경우이다.
비교 횟수는 최선, 평균, 최악의 경우가 모두 O(N^2)으로 일정하다.  

단점: 이동 횟수는 3n으로 선택정렬, 삽입정렬보다 이동을 더 자주 한다. 이동횟수가 큰 정렬방식은 비효율적이다.

### 4. 퀵 정렬 [시간복잡도:  O(N log2 N)]

divide and conquer 방식을 사용한다.
퀵 정렬은 인접한 원소를 교환하는 방식을 사용하는 삽입,선택,버블 정렬과 다르게 먼 거리의 데이터를 교환하여 불필요한 이동횟수를 줄인다. 
피봇`(pivot)`은 비교 대상이 될 기준으로, 비교 전에 설정해야한다.
피봇보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동한다.
나누어진 좌우의 리스트에도 피봇을 설정하며 리스트의 원소 개수가 1개가 될 때까지 반복하여 비교한다.

피봇을 기준으로 한 쪽이 크게 치우치게 된다면 퀵 정렬의 성능은 저하한다. 그렇기 때문에 퀵 정렬은 배열의 중앙값으로 설정하는 것이 가장 효율적이다.

이미 정렬된 데이터를 수행할 경우 수행시간이 더 많이 걸린다. 
시간 복잡도는 O(N log2 N) 이지만, 최악의 경우에는 피봇을 n번 결정하고 n번 비교하게 되어 O(N^2)의 시간 복잡도를 가진다.



## 수행시간 결과 그래프 분석

x축은 2의 지수, y축은 수행시간 (단위:초)이다.

![랜덤](https://user-images.githubusercontent.com/80513292/166956003-261b8cfc-6aaf-4333-a302-005189ab9d57.png)

랜덤으로 입력된 데이터를 정렬했을 때, 시간복잡도 O(N^2)은 삽입정렬, 선택정렬, 버블정렬 모두 같지만 이동횟수가 각각 2(n-1), 3(n-1), 3n으로 차이가 있기 때문에 수행 시간도 그에따라 크게 벌어졌다. 퀵정렬은 세 정렬방법에 비해 빠른 수행시간으로 그래프에서는 잘 보이지 않는다.

![정렬](https://user-images.githubusercontent.com/80513292/166956048-5f484b9a-a339-46e3-917f-4302b65292e6.png)

정렬된 데이터를 알고리즘이 수행했을 때, 선택정렬은 수행하기 최적의 조건이 된다. 따라서 선택 정렬의 수행시간은 다른 세가지 정렬방법보다 빠르다. 퀵 정렬은 전체적으로 봤을 때, 빠르다는 장점이 있었지만 정렬된 데이터를 다시 비교 확인하는 수행이 되기 때문에 버블 정렬과 비슷한 수행시간이 걸렸다.

![역순](https://user-images.githubusercontent.com/80513292/166956068-77a34b92-4df7-497c-9deb-9e068045d860.png)

역순으로 입력된 데이터를 순서대로 정렬할 때, 퀵 정렬의 수행이 2의 12제곱까지만 실행되어 유의미한 결과를 얻을 수 없었다. 버블 정렬 또한 2의 20제곱 개 데이터를 수행하는데에 긴 시간이 걸려 결국 노트북이 다운되어 결과를 얻을 수 없었다. 삽입 정렬이 선택 정렬보다 더 오래 걸렸다는 결과를 알 수 있다.

![랜덤-로그](https://user-images.githubusercontent.com/80513292/166956093-f83383f5-a04f-49a8-9ea9-f4bff843c29e.png)

랜덤으로 입력된 데이터를 정렬한 수행 시간을 log2로 계산했을 때, 퀵 정렬은 완만한 수행시간 증가를, 선택정렬, 삽입정렬, 버블정렬은 비슷한 기울기를 갖고 있다.

![정렬-로그](https://user-images.githubusercontent.com/80513292/166956128-bd857090-fd08-46a0-8027-d59efb5e4313.png)

순서대로 입력된 데이터를 정렬한 수행 시간을 log2로 계산했을 때, 랜덤 데이터보다 버블정렬과 선택정렬의 수행시간의 격차가 거의 없어졌다. 삽입 정렬은 최적의 상태이기 때문에 계산 값도 가장 작다.

![역순-로그](https://user-images.githubusercontent.com/80513292/166956143-1d7e870d-22cb-477e-b29f-8145525d6446.png)

역순로 입력된 데이터를 정렬한 수행 시간을 log2로 계산했을 때, 퀵정렬은 적은 입력값부터 2의 12제곱까지 일정한 값을 가진다. 버블, 선택, 삽입 정렬은 거의 같은 변화량을 보인다.

