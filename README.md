# 선택 삽입 버블 퀵

방법의 장점과 단점, 다른 방법과의 비교, 시간 복잡도

------

> 구현이 단순하지만 수행이 느린 알고리즘: **선택정렬, 삽입정렬, 버블정렬**
>
> 구현이 복잡하지만 수행 시간이 짧은 알고리즘: **퀵 정렬**

### 1. 선택 정렬  [시간복잡도: O(N^2)]

가장 작은 원소를 선택하여 맨 앞으로 옮겨 정렬한다.
배열의 크기 N만큼 한 원소와 전체 원소를 비교한다. 모든 원소가 비교 대상이 될 때까지 비교한다.
장점: 구현이 간편하다. 이동횟수는 미리 결정된다. 이동횟수:  3(n-1)
단점: 이동횟수 3(n-1)은 큰 값이다. 느리기 때문에 비효율적이다.
중복된 값이 배열에 존재하는 경우 상대적인 위치가 불필요하게 변경된다.

### 2. 삽입 정렬 [시간복잡도: O(N^2)]

기존 배열에 새로운 원소를 맨 뒤에 삽입하여 순차적으로 비교한다.
*신규 원소만이 비교 대상* 이 되기 때문에 최적의 경우 시간복잡도가 O(N)이 될 수 있지만, 평균적으로 O(N^2)의 시간복잡도를 가지고 있다.

장점: 이미 정렬되어 있는 배열의 경우 계산 속도가 빠르다. 삽입 정렬은 선택정렬과 다르게 안정성을 만족한다. 이미 정렬된 원소는 다시 비교하지 않는다. 레코드가 미리 정렬되어 있거나 크기가 작은 경우에 유리하다.
단점: 레코드의 이동이2(n-1)번이다.  이동횟수가 크다. 느리기 때문에 비효율적이다.

### 3. 버블 정렬 [시간복잡도: O(N^2)]

인접한 두 개의 원소를 비교하며 서로의 자리를 바꾼다. 반복하다보면 큰 값이 계속해서 뒤로 이동하는 모습이다. 배열의 크기 N만큼 전체 원소와 대상 원소를 비교한다. 
장점: 비교 방법이 간편하기 때문에 구현이 쉽다. 다른 공간에 저장하지 않기 때문에 추가적인 메모리가 필요 없다. 최선의 경우는 자료가 이미 정렬되어 자리 이동을 하지 않는 경우이다.
비교 횟수는 최선, 평균, 최악의 경우가 모두 O(N^2)으로 일정하다.  

단점: 이동 횟수는 3n으로 선택정렬, 삽입정렬보다 이동을 더 자주 한다. 이동횟수가 큰 정렬방식은 비효율적이다.

### 4. 퀵 정렬 [시간복잡도:  O(N log2 N)]

divide and conquer 방식을 사용한다.
퀵 정렬은 인접한 원소를 교환하는 방식을 사용하는 삽입,선택,버블 정렬과 다르게 먼 거리의 데이터를 교환하여 불필요한 이동횟수를 줄인다. 
피봇`(pivot)`은 비교 대상이 될 기준으로, 비교 전에 설정해야한다.
피봇보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동한다.
나누어진 좌우의 리스트에도 피봇을 설정하며 리스트의 원소 개수가 1개가 될 때까지 반복하여 비교한다.

피봇을 기준으로 한 쪽이 크게 치우치게 된다면 퀵 정렬의 성능은 저하한다. 그렇기 때문에 퀵 정렬은 배열의 중앙값으로 설정하는 것이 가장 효율적이다.

이미 정렬된 데이터를 수행할 경우 수행시간이 더 많이 걸린다. 
시간 복잡도는 O(N log2 N) 이지만, 최악의 경우에는 피봇을 n번 결정하고 n번 비교하게 되어 O(N^2)의 시간 복잡도를 가진다.